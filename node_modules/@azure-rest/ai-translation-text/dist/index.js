'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var coreClient = require('@azure-rest/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespace(coreRestPipeline);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const APIM_KEY_HEADER_NAME = "Ocp-Apim-Subscription-Key";
const APIM_REGION_HEADER_NAME = "Ocp-Apim-Subscription-Region";
class TranslatorAuthenticationPolicy {
    constructor(credential) {
        this.name = "TranslatorAuthenticationPolicy";
        this.credential = credential;
    }
    sendRequest(request, next) {
        request.headers.set(APIM_KEY_HEADER_NAME, this.credential.key);
        request.headers.set(APIM_REGION_HEADER_NAME, this.credential.region);
        return next(request);
    }
}
class TranslatorAzureKeyAuthenticationPolicy {
    constructor(credential) {
        this.name = "TranslatorAzureKeyAuthenticationPolicy";
        this.credential = credential;
    }
    sendRequest(request, next) {
        request.headers.set(APIM_KEY_HEADER_NAME, this.credential.key);
        return next(request);
    }
}

// Copyright (c) Microsoft Corporation.
const DEFAULT_SCOPE = "https://cognitiveservices.azure.com/.default";
const DEFAULT_ENPOINT = "https://api.cognitive.microsofttranslator.com";
const PLATFORM_HOST = "cognitiveservices";
const PLATFORM_PATH = "/translator/text/v3.0";
function isKeyCredential(credential) {
    return (credential === null || credential === void 0 ? void 0 : credential.key) !== undefined;
}
function isTranslatorKeyCredential(credential) {
    return (credential === null || credential === void 0 ? void 0 : credential.key) !== undefined;
}
/** Policy that sets the api-version (or equivalent) to reflect the library version. */
const apiVersionPolicy = {
    name: "MTApiVersionPolicy",
    async sendRequest(request, next) {
        const param = request.url.split("?");
        if (param.length > 1) {
            const newParams = param[1].split("&");
            newParams.push("api-version=3.0");
            request.url = param[0] + "?" + newParams.join("&");
        }
        else {
            // no query parameters in request url
            request.url = param[0] + "?api-version=3.0";
        }
        return next(request);
    },
};
/**
 * Initialize a new instance of `TextTranslationClient`
 * @param endpoint type: string, Supported Text Translation endpoints (protocol and hostname, for example:
 *     https://api.cognitive.microsofttranslator.com).
 * @param options type: ClientOptions, the parameter for all optional parameters
 */
function createClient(endpoint, credential = undefined, options = {}) {
    var _a;
    let serviceEndpoint;
    if (!endpoint) {
        serviceEndpoint = DEFAULT_ENPOINT;
    }
    else if (endpoint.toLowerCase().indexOf(PLATFORM_HOST) !== -1) {
        serviceEndpoint = `${endpoint}${PLATFORM_PATH}`;
    }
    else {
        serviceEndpoint = endpoint;
    }
    const baseUrl = (_a = options.baseUrl) !== null && _a !== void 0 ? _a : `${serviceEndpoint}`;
    const userAgentInfo = `azsdk-js-ai-translation-text-rest/1.0.0-beta.1`;
    const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
        ? `${options.userAgentOptions.userAgentPrefix} ${userAgentInfo}`
        : `${userAgentInfo}`;
    options = Object.assign(Object.assign({}, options), { userAgentOptions: {
            userAgentPrefix,
        } });
    const client = coreClient.getClient(baseUrl, options);
    client.pipeline.addPolicy(apiVersionPolicy);
    if (isTranslatorKeyCredential(credential)) {
        const mtAuthneticationPolicy = new TranslatorAuthenticationPolicy(credential);
        client.pipeline.addPolicy(mtAuthneticationPolicy);
    }
    else if (isKeyCredential(credential)) {
        const mtKeyAuthenticationPolicy = new TranslatorAzureKeyAuthenticationPolicy(credential);
        client.pipeline.addPolicy(mtKeyAuthenticationPolicy);
    }
    else if (credential) {
        client.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
            credential: credential,
            scopes: DEFAULT_SCOPE,
        }));
    }
    return client;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const responseMap = {
    "GET /languages": ["200"],
    "POST /translate": ["200"],
    "POST /transliterate": ["200"],
    "POST /breaksentence": ["200"],
    "POST /dictionary/lookup": ["200"],
    "POST /dictionary/examples": ["200"],
};
function isUnexpected(response) {
    const lroOriginal = response.headers["x-ms-original-url"];
    const url = new URL(lroOriginal !== null && lroOriginal !== void 0 ? lroOriginal : response.request.url);
    const method = response.request.method;
    const pathDetails = responseMap[`${method} ${url.pathname}`];
    if (!pathDetails) {
        return true;
    }
    return !pathDetails.includes(response.status);
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function buildMultiCollection(queryParameters, parameterName) {
    return queryParameters
        .map((item, index) => {
        if (index === 0) {
            return item;
        }
        return `${parameterName}=${item}`;
    })
        .join("&");
}

// Copyright (c) Microsoft Corporation.

exports.buildMultiCollection = buildMultiCollection;
exports["default"] = createClient;
exports.isUnexpected = isUnexpected;
//# sourceMappingURL=index.js.map
